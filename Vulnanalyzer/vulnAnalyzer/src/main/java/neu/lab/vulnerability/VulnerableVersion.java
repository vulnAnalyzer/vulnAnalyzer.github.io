package neu.lab.vulnerability;

import com.google.common.collect.ImmutableList;
import neu.lab.unit.PropertyHelper;
import neu.lab.unit.Version;
import org.apache.maven.artifact.versioning.DefaultArtifactVersion;
import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
import org.eclipse.aether.impl.DefaultServiceLocator;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.resolution.VersionRangeRequest;
import org.eclipse.aether.resolution.VersionRangeResolutionException;
import org.eclipse.aether.resolution.VersionRangeResult;
import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
import org.eclipse.aether.spi.connector.transport.TransporterFactory;
import org.eclipse.aether.transport.http.HttpTransporterFactory;
import org.joda.time.Duration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonatype.goodies.packageurl.PackageUrl;
import org.sonatype.ossindex.service.api.componentreport.ComponentReport;
import org.sonatype.ossindex.service.api.componentreport.ComponentReportVulnerability;
import org.sonatype.ossindex.service.client.OssindexClient;
import org.sonatype.ossindex.service.client.OssindexClientConfiguration;
import org.sonatype.ossindex.service.client.cache.DirectoryCache;
import org.sonatype.ossindex.service.client.internal.OssindexClientImpl;
import org.sonatype.ossindex.service.client.internal.VersionSupplier;
import org.sonatype.ossindex.service.client.marshal.GsonMarshaller;
import org.sonatype.ossindex.service.client.marshal.Marshaller;
import org.sonatype.ossindex.service.client.transport.*;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;


public class VulnerableVersion {
    private final static Logger log = LoggerFactory.getLogger(VulnerableVersion.class);

    /**
     * 获取版本范围
     * e.g. "org.apache.poi", "poi-ooxml", ":[5,)
     *
     * @param groupId
     * @param artifactId
     * @param version
     */
    public List<PackageUrl> getVersionRange(String groupId, String artifactId, String version) {
        // 初始化 RepositorySystem
        RepositorySystem system = newRepositorySystem();

        // 初始化 RepositorySystemSession
        RepositorySystemSession session = newRepositorySystemSession(system);
        // 构造 Maven 坐标
        DefaultArtifact artifact = new DefaultArtifact(groupId + ":" + artifactId + ":(," + version + ")");

        // 设置远程仓库（Maven Central）
        List<RemoteRepository> repositories = new ArrayList<>();
        repositories.add(new RemoteRepository.Builder("central", "default", "https://repo.maven.apache.org/maven2").build());

        // 进行版本范围请求
        VersionRangeRequest rangeRequest = new VersionRangeRequest();
        rangeRequest.setArtifact(artifact);
        rangeRequest.setRepositories(repositories);

        // 解析版本范围结果
        VersionRangeResult rangeResult = null;
        try {
            // Todo mysql:mysql-connector-java:5.1.48存在问题,8.0.7-dmr,找到的确实8.0.7
            rangeResult = system.resolveVersionRange(session, rangeRequest);
        } catch (VersionRangeResolutionException e) {
            log.info("VersionRangeResolutionException");
        }
        // 输出所有版本
        return rangeResult.getVersions().stream().map(newVersion -> packageUrl(groupId, artifactId, newVersion.toString())).collect(Collectors.toList());
    }

    /**
     * 获取与补丁相邻的漏洞版本
     *
     * @return
     */
    public Map<String[], String> getAdjacentVulnerability(Set<String> patchedVersions) {
        Map<String[], List<PackageUrl>> checks = new HashMap<>();
        for (String patch : patchedVersions) {
            String[] artifact = getArtifact(patch);
            try {
                log.info("start artifact: {}:{}:{}", artifact[0], artifact[1], artifact[2]);
                List<PackageUrl> packageUrls = getVersionRange(artifact[0], artifact[1], artifact[2]);
                checks.put(artifact, packageUrls);
            } catch (Exception e) {
                log.error("出错的artifactID: {}", Arrays.toString(artifact));
            }

        }
        Map<String[], String> results = new HashMap<>();
        for (Map.Entry<String[], List<PackageUrl>> entry : checks.entrySet()) {
            String[] key = entry.getKey();
            String version = key[2];
            List<PackageUrl> values = entry.getValue();
            if (values.isEmpty()) {
                results.put(key, version);
            } else {
                String previousVersion = findPreviousVersion(values, version);
                results.put(key, previousVersion);
                log.info("found previous version: {}", previousVersion);
            }
        }

        return results;
    }

    public String[] getArtifact(String vulnerability) {
        String[] parts = vulnerability.split(":");
        if (parts.length > 3) {
            return new String[]{parts[0], parts[1], parts[3]};
        } else {
            return parts;
        }
    }

    /**
     * 选择与给定版本最近的版本
     *
     * @param versions
     * @param targetVersion
     * @return
     */
    private String findPreviousVersion(List<PackageUrl> versions, String targetVersion) {
        DefaultArtifactVersion target = new DefaultArtifactVersion(targetVersion);
        DefaultArtifactVersion previous = null;

        for (PackageUrl versionStr : versions) {
            DefaultArtifactVersion version = new DefaultArtifactVersion(Objects.requireNonNull(versionStr.getVersion()));

            // 只考虑比目标版本小的版本
            if (version.compareTo(target) < 0) {
                // 找到最大的比目标小的版本
                if (previous == null || version.compareTo(previous) > 0) {
                    previous = version;
                }
            }
        }
        return previous != null ? previous.toString() : targetVersion;
    }


    static PackageUrl packageUrl(String groupId, String artifactId, String version) {
        return PackageUrl.builder()
                .type("maven")
                .namespace(groupId)
                .name(artifactId)
                .version(version)
                .build();
    }

    /**
     * Create client to communicate with OSS Index.
     */
    OssindexClient createClient() {
        UserAgentSupplier userAgent = new UserAgentSupplier(new VersionSupplier().get()) {
            /**
             * Customize with details from request if present.
             */
            @Override
            protected void customize(final UserAgentBuilder builder) {
                List<UserAgentBuilder.Product> products = ImmutableList.of(
//                        new UserAgentBuilder.Product("Maven", Variable.i().getMavenVersion()),
                        new UserAgentBuilder.Product("Enforcer-Rule", Version.get().getVersion())
                );
                for (UserAgentBuilder.Product product : products) {
                    builder.product(product);
                }
            }
        };
        Transport transport = new HttpClientTransport(userAgent);
        Marshaller marshaller = new GsonMarshaller();

        OssindexClientConfiguration config = new OssindexClientConfiguration();
        Properties properties = new Properties();
        // maybe disable persistent cache
        boolean cacheDisabled = PropertyHelper.getBoolean(properties, "ossindex.cache.disable", false);
        if (cacheDisabled) {
            // null will default to memory cache
            config.setCacheConfiguration(null);
        } else if (config.getCacheConfiguration() == null) {
            // if cache not otherwise configured, then prepare directory cache
            DirectoryCache.Configuration cacheConfig = new DirectoryCache.Configuration();
            // allow user to change the default location of the cache
            File cacheDir = PropertyHelper.getFile(properties, "ossindex.cache.directory");
            if (cacheDir != null) {
                cacheConfig.setBaseDir(cacheDir.toPath());
            }

            // allow user to change the default cache expiration
            Duration expiration = PropertyHelper.getDuration(properties, "ossindex.cache.expiration");
            if (expiration != null) {
                cacheConfig.setExpireAfter(expiration);
            }

            config.setCacheConfiguration(cacheConfig);
            AuthConfiguration authConfiguration = new AuthConfiguration();

            try (InputStream input = VulnerableVersion.class.getClassLoader().getResourceAsStream("OSSIndex.properties");) {
                properties.load(input);
                authConfiguration.setUsername(properties.getProperty("username"));
                authConfiguration.setPassword(properties.getProperty("password"));
                config.setAuthConfiguration(authConfiguration);
            } catch (IOException e) {
                log.info("IOException");
            }
        }

        return new OssindexClientImpl(config, transport, marshaller);
    }

    // 检查每个版本的漏洞情况，并返回无漏洞的版本
    private List<PackageUrl> getSafeVersions(List<PackageUrl> packageUrls) {
        OssindexClient client = createClient();
        List<PackageUrl> safeVersions = new ArrayList<>();
        try {
            Map<PackageUrl, ComponentReport> reports = client.requestComponentReports(packageUrls);
            for (Map.Entry<PackageUrl, ComponentReport> packageUrlComponentReportEntry : reports.entrySet()) {
                List<ComponentReportVulnerability> vulnerabilities = packageUrlComponentReportEntry.getValue().getVulnerabilities();
                // 检查是否有漏洞
                if (vulnerabilities == null || vulnerabilities.isEmpty()) {
                    safeVersions.add(packageUrlComponentReportEntry.getKey());
                }
            }
        } catch (Exception ignored) {
        }
        return safeVersions;
    }

    /**
     * 初始化 RepositorySystem
     *
     * @return
     */
    private static RepositorySystem newRepositorySystem() {
        DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
        locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
        locator.addService(TransporterFactory.class, HttpTransporterFactory.class);

        locator.setErrorHandler(new DefaultServiceLocator.ErrorHandler() {
            @Override
            public void serviceCreationFailed(Class<?> type, Class<?> impl, Throwable exception) {
                exception.printStackTrace();
            }
        });

        return locator.getService(RepositorySystem.class);
    }

    /**
     * 初始化 RepositorySystemSession
     *
     * @param system
     * @return
     */
    private static RepositorySystemSession newRepositorySystemSession(RepositorySystem system) {
        DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();

        // 设置本地仓库
        LocalRepository localRepo = new LocalRepository("target/local-repo");
        session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));
        return session;
    }
}
