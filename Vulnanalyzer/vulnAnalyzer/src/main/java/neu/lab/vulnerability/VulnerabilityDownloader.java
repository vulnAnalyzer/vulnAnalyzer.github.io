package neu.lab.vulnerability;

import neu.lab.unit.UniqueLineAppender;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class VulnerabilityDownloader {
    private final static Logger log = LoggerFactory.getLogger(VulnerabilityDownloader.class);

    /**
     * 根据补丁列表下载补丁和漏洞版本的源码
     */
    public void getPatchedAndVulnerableVersion() {
        String inputFile = "src/main/resources/gav_list.txt";
        String outputDir = "E:\\work4\\patch";
        String patchedPath = "src/main/resources/patchedPath.txt";
        try {
            Set<String> gavList = new HashSet<>(Files.readAllLines(Paths.get(inputFile)));
            VulnerableVersion vulnerableVersion = new VulnerableVersion();
            Map<String[], String> patchedAndAdjacentVulnerableVersion = vulnerableVersion.getAdjacentVulnerability(gavList);
            UniqueLineAppender uniqueLineAppender = new UniqueLineAppender();
            StringBuilder patchedLog = new StringBuilder();
            for (Map.Entry<String[], String> gav : patchedAndAdjacentVulnerableVersion.entrySet()) {
                patchedLog.setLength(0);
                String[] parts = gav.getKey();
                String groupId = parts[0], artifactId = parts[1], version = parts[2];
                // 补丁版本
                String id = groupId + ":" + artifactId + ":" + version;
                patchedLog.append(id).append(";");
                log.info("Processing: {}", id);
                // 获取最近的漏洞版本
                String vulGav = gav.getValue();
                if (vulGav == null) {
                    log.info("No vulnerability found for: {}", gav);
                    continue;
                }
                if (!(urlExists(groupId, artifactId, version) && urlExists(groupId, artifactId, vulGav))) {
                    log.info("No vulnerability URL: {}", id);
                    continue;
                }
                String patchedSourcePath = outputDir + "/" + artifactId + "-" + version + "-sources.jar";
                patchedLog.append(patchedSourcePath).append(";");
                String vulnerableSourcePath = outputDir + "/" + artifactId + "-" + vulGav + "-sources.jar";
                patchedLog.append(vulnerableSourcePath);
                boolean res = uniqueLineAppender.appendIfNotExists(patchedPath, patchedLog.toString());
                if (res) {
                    // 下载源码
                    downloadSourceJar(groupId, artifactId, version, outputDir);
                    downloadSourceJar(groupId, artifactId, vulGav, outputDir);
                    log.info("Downloaded: {} and {}", vulnerableSourcePath, patchedSourcePath);
                } else {
                    log.info("Context Exists!!!");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 4. 下载源码 JAR
    private void downloadSourceJar(String groupId, String artifactId, String version, String outputDir) {
        String jarUrl = String.format("https://repo1.maven.org/maven2/%s/%s/%s/%s-%s-sources.jar",
                groupId.replace(".", "/"), artifactId, version, artifactId, version);
        String filePath = outputDir + "/" + artifactId + "-" + version + "-sources.jar";
        // 下载文件
        try (InputStream in = new URL(jarUrl).openStream()) {
            Files.copy(in, Paths.get(filePath));
        } catch (IOException e) {
            log.error("Failed to download: {}", jarUrl);
        }
    }

    private boolean urlExists(String groupId, String artifactId, String version) {
        try {
//            String jarUrl = String.format("https://repo1.maven.org/maven2/%s/%s/%s/%s-%s-sources.jar",
            String jarUrl = String.format("https://repo1.maven.org/maven2/%s/%s/%s/%s-%s.war",
                    groupId.replace(".", "/"), artifactId, version, artifactId, version);
            URL url = new URL(jarUrl);
            HttpURLConnection http = (HttpURLConnection) url.openConnection();
            http.setRequestMethod("HEAD");
            http.setConnectTimeout(5000); // 设置连接超时
            http.setReadTimeout(5000);    // 设置读取超时

            int responseCode = http.getResponseCode();
            return (responseCode >= 200 && responseCode < 400); // 200~399 表示存在
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * 根据补丁列表下载补丁和漏洞版本的字节码
     */
    public void getPatchedAndVulnerableVersionBytecode() {
        String inputFile = "src/main/resources/gavCommits.txt";
        String outputDir = "E:\\work4\\vulnerability";
        Map<String, String> map = new HashMap<>();
        try {
            Set<String> gavList = new HashSet<>(Files.readAllLines(Paths.get(inputFile)));
            VulnerableVersion vulnerableVersion = new VulnerableVersion();
            Map<String[], String> patchedAndAdjacentVulnerableVersion = vulnerableVersion.getAdjacentVulnerability(gavList);
            for (Map.Entry<String[], String> gav : patchedAndAdjacentVulnerableVersion.entrySet()) {
                String[] parts = gav.getKey();
                String groupId = parts[0], artifactId = parts[1], version = parts[2];
//                // 补丁版本
                String id = groupId + ":" + artifactId + ":" + version;
//                log.info("Processing: {}", id);
                // 获取最近的漏洞版本
                String vulGav = gav.getValue();
                if (vulGav == null) {
                    log.info("No vulnerability found for: {}", gav);
                    continue;
                }
                map.put(id, groupId + ":" + artifactId + ":" + vulGav);
//                if (!(urlExists(groupId, artifactId, version) && urlExists(groupId, artifactId, vulGav))) {
//                    log.info("No vulnerability URL: {}", id);
//                    continue;
//                }
//                String vulnerableSourcePath = outputDir + "/" + artifactId + "-" + vulGav + ".jar";
                // 下载lo
//                downloadJar(groupId, artifactId, vulGav, outputDir);
//                log.info("Downloaded: {}", vulnerableSourcePath);
            }
            for (Map.Entry<String, String> entry : map.entrySet()) {
                System.out.println(entry.getKey() + "@" + entry.getValue());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // 4. 下载 JAR
    private void downloadJar(String groupId, String artifactId, String version, String outputDir) {
        String jarUrl = String.format("https://repo1.maven.org/maven2/%s/%s/%s/%s-%s.war",
                groupId.replace(".", "/"), artifactId, version, artifactId, version);
        String filePath = outputDir + "/" + artifactId + "-" + version + ".war";
        // 下载文件
        try (InputStream in = new URL(jarUrl).openStream()) {
            Files.copy(in, Paths.get(filePath));
        } catch (IOException e) {
            log.error("Failed to download: {}", jarUrl);
        }
    }
}

